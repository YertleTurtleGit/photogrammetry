const LUMINANCE_CHANNEL_QUANTIFIER={RED:.2126,GREEN:.7152,BLUE:.0722},GPU_GL_FLOAT_PRECISION={MEDIUM:"mediump",HIGH:"highp"},FLOAT_PRECISION=GPU_GL_FLOAT_PRECISION.HIGH,GLSL_VARIABLE={UV:"uv",UV_U:"uv[0]",UV_V:"uv[1]",TEX:"tex",POS:"pos",OUT:"fragColor"},GLSL_VARIABLE_TYPE={FLOAT:"float",VECTOR2:"vec2",VECTOR3:"vec3",VECTOR4:"vec4",MATRIX3:"mat3",INTEGER:"int"},OPERATOR_TYPE={SYMBOL:0,METHOD:1,CUSTOM:2},GLSL_OPERATOR={ADD:{GLSL_NAME:" + ",TYPE:OPERATOR_TYPE.SYMBOL},SUBTRACT:{GLSL_NAME:" - ",TYPE:OPERATOR_TYPE.SYMBOL},MULTIPLY:{GLSL_NAME:" * ",TYPE:OPERATOR_TYPE.SYMBOL},DIVIDE:{GLSL_NAME:" / ",TYPE:OPERATOR_TYPE.SYMBOL},ABS:{GLSL_NAME:"abs",TYPE:OPERATOR_TYPE.METHOD},MAXIMUM:{GLSL_NAME:"max",TYPE:OPERATOR_TYPE.METHOD},MINIMUM:{GLSL_NAME:"min",TYPE:OPERATOR_TYPE.METHOD},DOT:{GLSL_NAME:"dot",TYPE:OPERATOR_TYPE.METHOD},INVERSE:{GLSL_NAME:"inverse",TYPE:OPERATOR_TYPE.METHOD},NORMALIZE:{GLSL_NAME:"normalize",TYPE:OPERATOR_TYPE.METHOD},LENGTH:{GLSL_NAME:"length",TYPE:OPERATOR_TYPE.METHOD},SINE:{GLSL_NAME:"sin",TYPE:OPERATOR_TYPE.METHOD},COSINE:{GLSL_NAME:"cos",TYPE:OPERATOR_TYPE.METHOD},ARC_COSINE:{GLSL_NAME:"acos",TYPE:OPERATOR_TYPE.METHOD},RADIANS:{GLSL_NAME:"radians",TYPE:OPERATOR_TYPE.METHOD},SIGN:{GLSL_NAME:"sign",TYPE:OPERATOR_TYPE.METHOD},STEP:{GLSL_NAME:"step",TYPE:OPERATOR_TYPE.METHOD},DISTANCE:{GLSL_NAME:"distance",TYPE:OPERATOR_TYPE.METHOD},LUMINANCE:{GLSL_NAME:"luminance",TYPE:OPERATOR_TYPE.CUSTOM},CHANNEL:{GLSL_NAME:"channel",TYPE:OPERATOR_TYPE.CUSTOM},VEC3_TO_VEC4:{GLSL_NAME:"vec3_to_vec4",TYPE:OPERATOR_TYPE.CUSTOM}};class Shader{constructor(t){this.glslShader=null,this.dimensions=t}bind(){null!==this.glslShader&&console.warn("Shader is already bound!"),this.glslShader=new GlslShader(this.dimensions)}unbind(){GlslShader.currentShader=null,this.glslShader=null}purge(){null===this.glslShader?console.warn("No shader bound to purge!"):(this.glslShader.reset(),this.unbind())}getUV(){return new GlslVector2(void 0,GLSL_VARIABLE.UV)}}class GlslShader{constructor(t){GlslShader.currentShader=this,this.floatPrecision=FLOAT_PRECISION,this.glslImages=[],this.glslCommands=[],this.glslContext=new GlslContext(t)}static getCurrentShader(){return GlslShader.currentShader}reset(){this.glslContext.reset(),GlslShader.currentShader=null}static addGlslCommandToCurrentShader(t){GlslShader.getCurrentShader().addGlslCommand(t)}static addGlslImageToCurrentShader(t){GlslShader.getCurrentShader().addGlslImage(t)}static getGlslContext(){return GlslShader.getCurrentShader().glslContext}getGlslImages(){return this.glslImages}getVertexShaderSource(){return["#version 300 es","","in vec3 "+GLSL_VARIABLE.POS+";","in vec2 "+GLSL_VARIABLE.TEX+";","","out vec2 "+GLSL_VARIABLE.UV+";","","void main() {",GLSL_VARIABLE.UV+" = "+GLSL_VARIABLE.TEX+";","gl_Position = vec4("+GLSL_VARIABLE.POS+", 1.0);","}"].join("\n")}getFragmentShaderSource(t){let e=[];for(let t=0;t<this.glslImages.length;t++)e.push(this.glslImages[t].getGlslDefinition());return["#version 300 es","precision "+this.floatPrecision+" float;","","in vec2 "+GLSL_VARIABLE.UV+";","out vec4 "+GLSL_VARIABLE.OUT+";","",...e,"","float luminance(vec4 image) {","return image.r * "+GlslFloat.getJsNumberAsString(LUMINANCE_CHANNEL_QUANTIFIER.RED)+" + image.g * "+GlslFloat.getJsNumberAsString(LUMINANCE_CHANNEL_QUANTIFIER.GREEN)+" + image.b * "+GlslFloat.getJsNumberAsString(LUMINANCE_CHANNEL_QUANTIFIER.BLUE)+";","}","","void main() {",...this.glslCommands,GLSL_VARIABLE.OUT+" = "+t.getGlslName()+";","}"].join("\n")}addGlslCommand(t){this.glslCommands.push(t)}addGlslImage(t){this.glslImages.push(t)}}GlslShader.currentShader;class GlslContext{constructor(t){this.glslShader=GlslShader.getCurrentShader(),this.glCanvas=document.createElement("canvas"),this.glCanvas.width=t.width,this.glCanvas.height=t.height,this.glContext=this.glCanvas.getContext("webgl2")}reset(){this.glContext.flush(),this.glContext.finish(),this.glCanvas.remove(),this.glContext.getExtension("WEBGL_lose_context").loseContext()}getGlContext(){return this.glContext}renderPixelArray(t){return this.renderToPixelArray(t)}renderDataUrl(){return this.glCanvas.toDataURL()}createShaderProgram(t){let e=this.glContext.createShader(this.glContext.VERTEX_SHADER),l=this.glContext.createShader(this.glContext.FRAGMENT_SHADER);const r=this.glslShader.getVertexShaderSource(),s=this.glslShader.getFragmentShaderSource(t);console.log(s),this.glContext.shaderSource(e,r),this.glContext.shaderSource(l,s),this.glContext.compileShader(e),this.glContext.compileShader(l);let a=this.glContext.createProgram();return this.glContext.attachShader(a,e),this.glContext.attachShader(a,l),this.glContext.linkProgram(a),a}loadGlslImages(t){const e=this.glslShader.getGlslImages();for(let l=0;l<e.length;l++)e[l].loadIntoShaderProgram(this.glContext,t,l)}getFrameVAO(t){const e=this.glContext.getAttribLocation(t,GLSL_VARIABLE.POS),l=this.glContext.getAttribLocation(t,GLSL_VARIABLE.TEX),r=Float32Array.BYTES_PER_ELEMENT;let s=this.glContext.createVertexArray();this.glContext.bindVertexArray(s);let a=this.glContext.createBuffer();this.glContext.bindBuffer(this.glContext.ARRAY_BUFFER,a),this.glContext.bufferData(this.glContext.ARRAY_BUFFER,new Float32Array([-1,1,1,1,-1,-1,-1,-1,1,1,1,-1]),this.glContext.STATIC_DRAW),this.glContext.vertexAttribPointer(e,2,this.glContext.FLOAT,!1,2*r,0),this.glContext.enableVertexAttribArray(e),this.glContext.bindBuffer(this.glContext.ARRAY_BUFFER,null);let i=this.glContext.createBuffer();return this.glContext.bindBuffer(this.glContext.ARRAY_BUFFER,i),this.glContext.bufferData(this.glContext.ARRAY_BUFFER,new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]),this.glContext.STATIC_DRAW),this.glContext.vertexAttribPointer(l,2,this.glContext.FLOAT,!1,2*r,0),this.glContext.enableVertexAttribArray(l),this.glContext.bindBuffer(this.glContext.ARRAY_BUFFER,null),this.glContext.bindVertexArray(null),s}drawArraysFromVAO(t){this.glContext.viewport(0,0,this.glCanvas.width,this.glCanvas.height),this.glContext.clearColor(0,0,0,0),this.glContext.clear(this.glContext.COLOR_BUFFER_BIT|this.glContext.DEPTH_BUFFER_BIT),this.glContext.blendFunc(this.glContext.SRC_ALPHA,this.glContext.ONE),this.glContext.enable(this.glContext.BLEND),this.glContext.disable(this.glContext.DEPTH_TEST),this.glContext.bindVertexArray(t),this.glContext.drawArrays(this.glContext.TRIANGLES,0,6),this.glContext.bindVertexArray(null)}readToPixelArray(){let t=new Uint8Array(this.glCanvas.width*this.glCanvas.height*4);return this.glContext.readPixels(0,0,this.glCanvas.width,this.glCanvas.height,this.glContext.RGBA,this.glContext.UNSIGNED_BYTE,t),t}renderToPixelArray(t){this.drawCall(t);return this.readToPixelArray()}drawCall(t){const e=this.createShaderProgram(t);this.glContext.useProgram(e),this.loadGlslImages(e);const l=this.getFrameVAO(e);this.drawArraysFromVAO(l)}}class GlslRendering{constructor(t,e){this.glslContext=t,this.outVariable=e}static render(t){return new GlslRendering(GlslShader.getGlslContext(),t)}getPixelArray(){return this.pixelArray||(this.pixelArray=this.glslContext.renderPixelArray(this.outVariable)),this.pixelArray}getDataUrl(){return this.dataUrl||(this.getPixelArray(),this.dataUrl=this.glslContext.renderDataUrl()),this.dataUrl}async getJsImage(){if(!this.jsImage){const t=this.getDataUrl();this.jsImage=await new Promise((e=>{const l=new Image;l.addEventListener("load",(()=>{e(l)})),l.src=t}))}return this.jsImage}}class GlslOperation{constructor(t,e,l,r){this.callingParameter=t,this.result=e,this.parameters=l,this.glslOperator=r}static getGlslExpressionOfParams(t,e){return 1===e.length?e[0]:2===e.length?t+"("+e[0]+", "+e[1]+")":t+"("+e.pop()+", "+GlslOperation.getGlslExpressionOfParams(t,e)+")"}getDeclaration(){const t=GlslVariable.getGlslNamesOfGlslVariables(this.parameters);if(this.glslOperator.TYPE===OPERATOR_TYPE.SYMBOL)return t.unshift(this.callingParameter.getGlslName()),this.result.getGlslName()+" = "+t.join(this.glslOperator.GLSL_NAME)+";";if(this.glslOperator.TYPE===OPERATOR_TYPE.METHOD)return this.glslOperator===GLSL_OPERATOR.MAXIMUM||this.glslOperator===GLSL_OPERATOR.MINIMUM?(t.unshift(this.callingParameter.getGlslName()),this.result.getGlslName()+" = "+GlslOperation.getGlslExpressionOfParams(this.glslOperator.GLSL_NAME,t)+";"):this.result.getGlslName()+" = "+this.glslOperator.GLSL_NAME+"("+t.join(", ")+");";if(this.glslOperator.TYPE===OPERATOR_TYPE.CUSTOM){if(this.glslOperator===GLSL_OPERATOR.CHANNEL)return this.result.getGlslName()+" = "+t[0]+"["+t[1]+"];";if(this.glslOperator===GLSL_OPERATOR.VEC3_TO_VEC4)return this.result.getGlslName()+" = vec4("+t[0]+", "+t[1]+");";if(this.glslOperator===GLSL_OPERATOR.LUMINANCE)return this.result.getGlslName()+" = "+this.glslOperator.GLSL_NAME+"("+t[0]+");"}}}class GlslImage{constructor(t){this.jsImage=t,this.uniformGlslName=GlslVariable.getUniqueName("uniform"),this.glslVector4=new GlslVector4(null,"texture("+this.uniformGlslName+", "+GLSL_VARIABLE.UV+")"),GlslShader.addGlslImageToCurrentShader(this)}static load(t){return new GlslImage(t).glslVector4}getGlslDefinition(){return"uniform sampler2D "+this.uniformGlslName+";"}createBaseTexture(t){let e=t.createTexture();return t.bindTexture(t.TEXTURE_2D,e),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,this.jsImage),e}loadIntoShaderProgram(t,e,l){t.activeTexture(t.TEXTURE0+l),t.bindTexture(t.TEXTURE_2D,this.createBaseTexture(t)),t.uniform1i(t.getUniformLocation(e,this.uniformGlslName),l)}applyFilter(t,e=!1){const l=t.length;let r="";if(e){let e=0;t.forEach((t=>{t.forEach((t=>{e+=t}))})),0!==e&&t.forEach(((l,r)=>{l.forEach(((l,s)=>{t[r][s]=l/e}))}))}return t.forEach(((t,e)=>{t.forEach(((t,s)=>{r+=" + "+GlslFloat.getJsNumberAsString(t)+" * "+this.getNeighborPixel(s-Math.floor(l/2),e-Math.floor(l/2)).getGlslName()}))})),new GlslVector4(null,r)}getNeighborPixel(t,e){const l=GlslFloat.getJsNumberAsString(1/this.jsImage.width*t),r=GlslFloat.getJsNumberAsString(1/this.jsImage.height*e);return new GlslVector4(null,"texture("+this.uniformGlslName+", vec2("+GLSL_VARIABLE.UV_U+" + "+l+", "+GLSL_VARIABLE.UV_V+" + "+r+"))")}}class GlslVariable{constructor(t=""){this.glslName=GlslVariable.getUniqueName(this.getGlslVarType()),null!==t&&(""!==t&&(t=" = "+t),GlslShader.addGlslCommandToCurrentShader(this.getGlslVarType()+" "+this.getGlslName()+t+";"))}static getUniqueName(t){return GlslVariable.uniqueNumber++,t+"_"+GlslVariable.uniqueNumber.toString()}static getGlslNamesOfGlslVariables(t){let e=[];if(null!==t)for(let l=0;l<t.length;l++)e.push(t[l].getGlslName());return e}getGlslName(){return this.glslName}declareGlslResult(t){GlslShader.addGlslCommandToCurrentShader(t.getDeclaration())}getGlslFloatResult(t,e){const l=new GlslFloat;return this.declareGlslResult(new GlslOperation(this,l,t,e)),l}getGlslVector3Result(t,e){const l=new GlslVector3;return this.declareGlslResult(new GlslOperation(this,l,t,e)),l}getGlslVector4Result(t,e){const l=new GlslVector4;return this.declareGlslResult(new GlslOperation(this,l,t,e)),l}getGlslMatrix3Result(t,e){const l=new GlslMatrix3;return this.declareGlslResult(new GlslOperation(this,l,t,e)),l}getGlslVarType(){throw new Error("Cannot call an abstract method.")}}GlslVariable.uniqueNumber=0;class GlslVector extends GlslVariable{channel(t){return this.getGlslFloatResult([this,new GlslInteger(t)],GLSL_OPERATOR.CHANNEL)}}class GlslMatrix extends GlslVariable{}class GlslInteger extends GlslVariable{constructor(t=null){null!==t?(super(null),this.glslName=Math.floor(t).toString()):super()}getGlslVarType(){return GLSL_VARIABLE_TYPE.INTEGER}}class GlslFloat extends GlslVariable{static getJsNumberAsString(t){return Math.trunc(t)===t?t.toString()+".0":t.toString().includes("e-")?"0.0":t.toString()}constructor(t=null){null!==t?(super(null),this.glslName=GlslFloat.getJsNumberAsString(t)):super()}getGlslName(){return this.glslName}getGlslVarType(){return GLSL_VARIABLE_TYPE.FLOAT}addFloat(...t){return this.getGlslFloatResult(t,GLSL_OPERATOR.ADD)}addVector3(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.ADD)}addVector4(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.ADD)}addMatrix3(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.ADD)}subtractFloat(...t){return this.getGlslFloatResult(t,GLSL_OPERATOR.SUBTRACT)}subtractVector3(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.SUBTRACT)}subtractVector4(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.SUBTRACT)}subtractMatrix3(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.SUBTRACT)}multiplyFloat(...t){return this.getGlslFloatResult(t,GLSL_OPERATOR.MULTIPLY)}multiplyVector3(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.MULTIPLY)}multiplyVector4(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.MULTIPLY)}multiplyMatrix3(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.MULTIPLY)}divideFloat(...t){return this.getGlslFloatResult(t,GLSL_OPERATOR.DIVIDE)}abs(){return this.getGlslFloatResult([this],GLSL_OPERATOR.ABS)}maximum(...t){return this.getGlslFloatResult(t,GLSL_OPERATOR.MAXIMUM)}minimum(...t){return this.getGlslFloatResult(t,GLSL_OPERATOR.MINIMUM)}radians(){return this.getGlslFloatResult([this],GLSL_OPERATOR.RADIANS)}sin(){return this.getGlslFloatResult([this],GLSL_OPERATOR.SINE)}cos(){return this.getGlslFloatResult([this],GLSL_OPERATOR.COSINE)}acos(){return this.getGlslFloatResult([this],GLSL_OPERATOR.ARC_COSINE)}sign(){return this.getGlslFloatResult([this],GLSL_OPERATOR.SIGN)}step(t=new GLSL.Float(.5)){return this.getGlslFloatResult([t,this],GLSL_OPERATOR.STEP)}}class GlslVector2 extends GlslVector{constructor(t,e){if(!e&&(e="",t)){let l=[];l.push(t[0].getGlslName()),l.push(t[1].getGlslName()),e=GLSL_VARIABLE_TYPE.VECTOR2+"("+l.join(", ")+")"}super(e)}getGlslVarType(){return GLSL_VARIABLE_TYPE.VECTOR2}distance(t){return this.getGlslFloatResult([this,t],GLSL_OPERATOR.DISTANCE)}}class GlslVector3 extends GlslVector{constructor(t){let e="";if(t){let l=[];l.push(t[0].getGlslName()),l.push(t[1].getGlslName()),l.push(t[2].getGlslName()),e=GLSL_VARIABLE_TYPE.VECTOR3+"("+l.join(", ")+")"}super(e)}getGlslVarType(){return GLSL_VARIABLE_TYPE.VECTOR3}addFloat(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.ADD)}addVector3(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.ADD)}addVector4(){throw new Error("Not possible to add vec4 to vec3.")}addMatrix3(){throw new Error("Not possible to add mat3 to vec3.")}subtractFloat(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.SUBTRACT)}subtractVector3(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.SUBTRACT)}subtractVector4(){throw new Error("Not possible to subtract vec4 from vec3.")}subtractMatrix3(){throw new Error("Not possible to subtract mat3 from vec3.")}multiplyFloat(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.MULTIPLY)}multiplyVector3(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.MULTIPLY)}multiplyVector4(){throw new Error("Not possible to multiply vec4 with vec3.")}multiplyMatrix3(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.MULTIPLY)}divideFloat(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.DIVIDE)}length(){return this.getGlslFloatResult([this],GLSL_OPERATOR.LENGTH)}abs(){return this.getGlslVector3Result([this],GLSL_OPERATOR.ABS)}normalize(){return this.getGlslVector3Result([this],GLSL_OPERATOR.NORMALIZE)}maximum(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.MAXIMUM)}minimum(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.MINIMUM)}dot(t){return this.getGlslFloatResult([this,t],GLSL_OPERATOR.DOT)}getVector4(t=new GlslFloat(1)){return this.getGlslVector4Result([this,t],GLSL_OPERATOR.VEC3_TO_VEC4)}}class GlslVector4 extends GlslVector{constructor(t,e=""){if(""===e&&t){let l=[];l.push(t[0].getGlslName()),l.push(t[1].getGlslName()),l.push(t[2].getGlslName()),l.push(t[3].getGlslName()),e=GLSL_VARIABLE_TYPE.VECTOR4+"("+l.join(", ")+")"}super(e)}getGlslVarType(){return GLSL_VARIABLE_TYPE.VECTOR4}addFloat(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.ADD)}addVector3(){throw new Error("Not possible to add vec3 to vec4.")}addVector4(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.ADD)}addMatrix3(){throw new Error("Not possible to add mat3 to vec4.")}subtractFloat(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.SUBTRACT)}subtractVector3(){throw new Error("Not possible to subtract vec3 from vec4.")}subtractVector4(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.SUBTRACT)}subtractMatrix3(){throw new Error("Not possible to subtract mat3 from vec4.")}multiplyFloat(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.MULTIPLY)}multiplyVector3(){throw new Error("Not possible to multiply vec3 with vec4.")}multiplyVector4(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.MULTIPLY)}multiplyMatrix3(){throw new Error("Not possible to multiply mat3 with vec4.")}divideFloat(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.DIVIDE)}abs(){return this.getGlslVector4Result([this],GLSL_OPERATOR.ABS)}length(){return this.getGlslFloatResult([this],GLSL_OPERATOR.LENGTH)}normalize(){return this.getGlslVector4Result([this],GLSL_OPERATOR.NORMALIZE)}maximum(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.MAXIMUM)}minimum(...t){return this.getGlslVector4Result(t,GLSL_OPERATOR.MINIMUM)}dot(t){return this.getGlslFloatResult([this,t],GLSL_OPERATOR.DOT)}getLuminance(){return this.getGlslFloatResult([this],GLSL_OPERATOR.LUMINANCE)}}class GlslMatrix3 extends GlslMatrix{constructor(t){let e="";if(void 0!==t){let l=[[null,null,null],[null,null,null],[null,null,null]];for(let e=0;e<t.length;e++)for(let r=0;r<t[0].length;r++)l[e][r]=t[e][r].getGlslName();void 0!==t&&(e=GLSL_VARIABLE_TYPE.MATRIX3+"("+l[0][0]+", "+l[1][0]+", "+l[2][0]+", "+l[0][1]+", "+l[1][1]+", "+l[2][1]+", "+l[0][2]+", "+l[1][2]+", "+l[2][2]+")")}super(e)}getGlslVarType(){return GLSL_VARIABLE_TYPE.MATRIX3}addFloat(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.ADD)}addVector3(){throw new Error("Not possible to add vec3 to mat3.")}addVector4(){throw new Error("Not possible to add vec4 to mat3.")}addMatrix3(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.ADD)}subtractFloat(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.SUBTRACT)}subtractVector3(){throw new Error("Not possible to subtract vec3 from mat3.")}subtractVector4(){throw new Error("Not possible to subtract vec4 from mat3.")}subtractMatrix3(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.SUBTRACT)}multiplyFloat(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.MULTIPLY)}multiplyVector3(...t){return this.getGlslVector3Result(t,GLSL_OPERATOR.MULTIPLY)}multiplyVector4(){throw new Error("Not possible to multiply vec4 with mat3.")}multiplyMatrix3(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.MULTIPLY)}divideFloat(...t){return this.getGlslMatrix3Result(t,GLSL_OPERATOR.DIVIDE)}inverse(){return this.getGlslMatrix3Result([this],GLSL_OPERATOR.INVERSE)}}const GLSL={Shader:Shader,render:GlslRendering.render,Image:GlslImage,Integer:GlslInteger,Float:GlslFloat,Vector2:GlslVector2,Vector3:GlslVector3,Vector4:GlslVector4,Matrix3:GlslMatrix3};
